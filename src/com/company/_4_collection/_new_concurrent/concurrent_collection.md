# Сoncurrent collections




ConcurrentDictionary: потокобезопасная коллекция общего назначения, применимая в самом широком спектре сценариев.

ConcurrentBag, ConcurrentStack, ConcurrentQueue: коллекции специального назначения. “Специальность” заключается в
следующих моментах:

* Отсутствие API для доступа к произвольному элементу
* Stack и Queue (как все мы знаем) имеют заданный порядок добавления и извлечения элементов
* ConcurrentBag для каждого потока поддерживает собственную коллекцию для добавления элементов. При извлечении он
  “крадет” элементы из соседнего потока, если у текущего потока коллекция пуста

IProducerConsumerCollection — контракт используемый классом BlockingCollection (см. ниже). Реализован коллекциями
ConcurrentStack, ConcurrentQueue и ConcurrentBag.

BlockingCollection — используется в сценариях, когда одни потоки заполняют коллекцию, а другие извлекают из нее
элементы. Типичный пример — пополняемая очередь задач. Если в момент запроса очередного элемента коллекция пуста, то
читающая сторона переходит в состояние ожидания нового элемента (polling). Вызвав метод CompleteAdding() мы можем
указать, что коллекция больше не будет пополняться, тогда при чтении polling выполняться не будет. Проверить состояние
коллекции можно с помощью свойств IsAddingCompleted (true если данные больше не будут добавляться) и IsCompleted (true
если данные больше не будут добавляться и коллекция пуста).

Partitioner, OrderablePartitioner, EnumerablePartitionerOptions — базовые конструкции для реализации сегментирования
коллекций. Используется методом Parallel.ForEach для указания, каким образом распределять элементы по обрабатывающим
потокам.
