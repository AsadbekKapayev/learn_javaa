## Что такое многопоточность?

это одновременное выполнение двух или более потоков для максимального использования центрального процессора

## Варианты создания потоков

Есть 3 вида: Thread, Runnable & Callable

## Thread name и Thread priority

### Thread Name (Имя потока):

Каждый объект Thread в Java может быть идентифицирован уникальным именем. Имя потока устанавливается при создании потока
с использованием конструктора, который принимает строку в качестве параметра

```
Thread myThread = new Thread("MyThreadName");
String threadName = Thread.currentThread().getName();
```

### Thread Priority (Приоритет потока):

Каждый поток имеет приоритет, который влияет на то, как поток будет выполняться относительно других потоков в системе.
Приоритеты определены в диапазоне от Thread.MIN_PRIORITY (1) до Thread.MAX_PRIORITY (10), и по умолчанию установлены на
среднее значение Thread.NORM_PRIORITY (5).

```
Thread myThread = new Thread();
myThread.setPriority(Thread.MAX_PRIORITY); // Установка максимального приоритета

int threadPriority = myThread.getPriority();
```

## Методы sleep и join. Thread states

### Thread States (Состояния потока):

* NEW (Новый): Поток создан, но не запущен.
* RUNNABLE (Выполняемый): Поток выполняется или готов к выполнению.
* BLOCKED (Заблокированный): Поток ожидает монитора для входа в блокированный регион.
* WAITING (Ожидание): Поток ожидает другого потока, чтобы выполнить определенное действие.
* TIMED_WAITING (Ожидание с тайм-аутом): Поток ждет определенное количество времени.
* TERMINATED (Завершенный): Поток завершил свое выполнение.

### Метод sleep()

Метод sleep() позволяет потоку приостановить свою работу на определенный период времени. Во время сна поток переходит в
состояние TIMED_WAITING (ожидание по времени).

### Метод join()

Метод join() позволяет потоку дождаться завершения выполнения другого потока. Когда поток вызывает join() на другом
потоке, он переходит в состояние WAITING (ожидание) до тех пор, пока другой поток не завершится.

## Понятия synchronous и asynchronous

### Synchronous (Синхронный)

Синхронный код выполняется последовательно, шаг за шагом. Каждая операция ждет завершения предыдущей, прежде чем начать
выполнение.

### Asynchronous (Асинхронный)

Асинхронный код позволяет выполнению переходить к следующей задаче, не ожидая завершения текущей операции. Вместо
блокировки выполнения кода ожиданием завершения, вы можете передать управление другой части программы.

## Concurrency Parallelism (Параллелизм)

Параллелизм - это концепция, связанная с одновременным выполнением нескольких задач в один и тот же момент времени. Он
подразумевает фактическое выполнение задач в параллельных процессорах или ядрах процессора для увеличения общей
производительности. Параллелизм обычно требует физических параллельных ресурсов, таких как многопроцессорные системы или
многозадачные системы.

## Blocking Parallelism (Блокирующий Параллелизм)

Блокирующий параллелизм связан с тем, когда одна задача блокирует или останавливает выполнение другой задачи до
завершения какого-то события или операции. Это может происходить, например, при ожидании завершения ввода-вывода (I/O)
или при ожидании данных из сети. Блокирующий параллелизм может снижать эффективность использования ресурсов, так как
одна задача не может продолжить выполнение, пока не будут выполнены условия, блокирующие другие задачи.

## Ключевое слово volatile

В Java ключевое слово volatile применяется к переменным и используется для гарантированной видимости изменений
переменной между потоками. Когда переменная объявлена с ключевым словом volatile, это гарантирует следующее:

* Видимость изменений. Если один поток модифицирует переменную, то изменения видны сразу же всем остальным потокам. Это
  исключает кеширование переменных в локальных кешах потоков.
* Атомарность чтения и записи (для переменных типа long и double). Операции чтения и записи для переменных типа long и
  double гарантировано атомарны, что означает, что операция не может быть разделена на несколько шагов. Это важно для
  избежания гонок данных в многопоточных сценариях.

## Data race. Synchronized methods

### Data Race (Гонка данных)

Гонка данных (Data Race) - это ситуация в многопоточной программе, при которой два или более потока обращаются к общему
ресурсу (например, переменной) без использования синхронизации, и хотя бы одна из операций - запись - выполняется. Гонки
данных могут привести к непредсказуемому и некорректному поведению программы. Они являются одним из типичных видов
ошибок в многопоточных приложениях.

### Synchronized Methods (Синхронизированные методы)

В Java ключевое слово synchronized используется для обеспечения синхронизации потоков и предотвращения гонок данных.
Синхронизированные методы обеспечивают блокировку на уровне объекта, что означает, что только один поток может выполнять
синхронизированный метод на данном объекте в любой момент времени.

## Понятие «монитор». Synchronized blocks

### Монитор

В программировании и многозадачности, монитор — это концепция, которая обеспечивает механизм синхронизации для контроля
доступа к общим ресурсам. Он гарантирует, что только один поток может выполнять критическую секцию кода (участок кода,
который обращается к общему ресурсу) в любой момент времени. Мониторы используются для предотвращения гонок данных и
других проблем, связанных с параллельным выполнением потоков. В Java мониторы реализованы через ключевое слово
synchronized и блоки синхронизации.

### Synchronized Blocks (Синхронизированные блоки)

В Java синхронизированные блоки используются для ограничения доступа к критическим секциям кода с использованием
монитора. Блокировка осуществляется на объекте, который называется монитором. Когда один поток входит в
синхронизированный блок, он захватывает монитор, предотвращая вход другим потокам в аналогичные синхронизированные
блоки.

## Методы wait и notify

### wait

Метод wait вызывается на объекте и заставляет текущий поток ожидать, пока другой поток не вызовет метод notify или
notifyAll для того же объекта.

### notify и notifyAll

Метод notify используется для уведомления одного из потоков, ожидающих на том же объекте. Если есть несколько потоков,
ожидающих, то выбирается один из них (неопределенный порядок выбора).

## Понятия Deadlock, Livelock, Lock Starvation

### Deadlock (взаимная блокировка)

Deadlock в Java может возникнуть, когда два или более потока ждут друг друга, чтобы освободить ресурсы, которые они
держат.

### Livelock (живая блокировка)

Livelock происходит, когда потоки активны, но не могут продвинуться вперед. В Java livelock может возникнуть при
использовании синхронизации и блокировок.

### Lock Starvation (голодание блокировки)

Lock Starvation возникает, когда потоки не получают доступ к ресурсам, которые они нуждаются из-за длительного ожидания
другими потоками.
